import "console"

struct Info {
    var test = 0
    var pointerTest = &test
}

fun main(): i32 {
    println("Hello World %i")
    var test = Info { test: 10, pointerTest: &test }
    test(&test)
    println("3) %i, %i", test.test, test.@pointerTest)
    return 0
}

fun test(ok: Info*): void {
    println("1) %i -> %i: %i", @ok.test, @ok.pointerTest, @ok.@pointerTest)
    @ok.test = 100
    @ok.pointerTest = @ok.&test
    println("2) %i -> %i: %i", @ok.test, @ok.pointerTest, @ok.@pointerTest)
}

## FUTURE CONCEPTS:

# 1.) Using call by reference instead of call by value (replacement for pointers)
# fun main(): i32 {
#     var test = Info { test: 10, pointerTest: &test }
#     test(test)
#     println("3) %i, %i", test.test, test.@pointerTest)
#     return 0
# }

# fun test(ok: Info&): void {
#     println("1) %i -> %i: %i", ok.test, ok.pointerTest, ok.@pointerTest)
#     ok.test = 100
#     ok.pointerTest = ok.&test
#     println("2) %i -> %i: %i", ok.test, ok.pointerTest, ok.@pointerTest)
# }

# 2.) Constant parameters
# fun main(): i32 {
#     const test = Info { test: 10, pointerTest: &test }
#     test(test)
#     println("3) %i, %i", test.test, test.@pointerTest)
#     return 0
# }

# fun test(const ok: Info&): void {
#     println("1) %i -> %i: %i", ok.test, ok.pointerTest, ok.@pointerTest)
#     ok.test = 100             
#     ok.pointerTest = ok.&test
#     println("2) %i -> %i: %i", ok.test, ok.pointerTest, ok.@pointerTest)
# }

# 3.) Compile-time functions for better performance
# [compile-time]
# fun add(const x, y: i32): i32 {
#     return x + y
# }
