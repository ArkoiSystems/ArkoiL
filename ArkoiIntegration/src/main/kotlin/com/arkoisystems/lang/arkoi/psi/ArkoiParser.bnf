{
    parserClass = 'com.arkoisystems.lang.arkoi.ArkoiParser'

    extends = 'com.intellij.extapi.psi.ASTWrapperPsiElement'

    psiClassPrefix = 'Arkoi'
    psiImplClassSuffix = 'Impl'
    psiPackage = 'com.arkoisystems.lang.arkoi.psi'
    psiImplPackage = 'com.arkoisystems.lang.arkoi.psi.impl'

    elementTypeHolderClass = 'com.arkoisystems.lang.arkoi.ArkoiTokenTypes'
    elementTypeClass = 'com.arkoisystems.lang.arkoi.psi.ArkoiElementType'
    tokenTypeClass = 'com.arkoisystems.lang.arkoi.psi.ArkoiTokenType'

    psiImplUtilClass = 'com.arkoisystems.lang.arkoi.psi.impl.ArkoiPsiImplUtil'

    tokens = [
        WHITE_SPACE = 'regexp:[ \n\r\t\f]'

        L_BRACKET = '['
        R_BRACKET = ']'

        L_PARENTHESIS = '('
        R_PARENTHESIS = ')'

        L_BRACE = '{'
        R_BRACE = '}'

        LESS_THAN = '<'
        GREATER_THAN = '>'

        EQUALS = '='
        SEMICOLON = ';'
        DOT = '.'
        COMMA = ','
        COLON = ':'
        AT = '@'

        ADD_ASSIGN = '+='
        SUB_ASSIGN = '-='
        MUL_ASSIGN = '*='
        DIV_ASSIGN = '/='
        MOD_ASSIGN = '%='
        EXP_ASSIGN = '**='

        DOUBLE_PLUS = '++'
        DOUBLE_MINUS = '--'
        DOUBLE_ASTERISK = '**'

        PLUS = '+'
        MINUS = '-'
        ASTERISK = '*'
        SLASH = '/'
        PERCENT = '%'

        NUMBER_LITERAL = 'regexp:\d+(\.\d*)?'
        STRING_LITERAL = 'regexp:"([^"\\]|\\.)*"'
        IDENTIFIER = 'regexp:[a-zA-Z_$][a-zA-Z0-9_$]*'

        COMMENT = 'regexp:#.*'
    ]

    name(".*expression") = 'expression'
}

root ::= (comment_declaration | class_statement)*

// COMMENTS

comment_declaration ::= line_comment

line_comment ::= COMMENT

// STATEMENT

private class_statement ::= (variable_declaration | function_declaration | import_declaration)

private block_statement ::= (identifier_call | variable_declaration | return_declaration)


import_declaration ::= import STRING_LITERAL (as IDENTIFIER) {
    pin = 1
    methods = [getName]
}

variable_declaration ::= (annotation_call | comment_declaration)* var IDENTIFIER inlined_block {
    pin = 2
    methods = [getName]
}

function_declaration ::= (annotation_call | comment_declaration)* fun IDENTIFIER LESS_THAN primitives? GREATER_THAN L_PARENTHESIS parameter_list? R_PARENTHESIS block_declaration {
    pin = 2
    methods = [
        getFunctionName
        getFunctionReturnType
        getFunctionBlock
        getFunctionParameters
        getFunctionAnnotations
    ]
}

return_declaration ::= return expression? {
    pin = 1
    methods = [
        getReturnDeclaration
    ]
}

identifier_call ::= (this DOT)? identifier_call_part (DOT identifier_call_part)*

identifier_call_part ::= IDENTIFIER function_call_part?  {
    methods = [
        getName
    ]
}

function_call_part ::= L_PARENTHESIS expression_list? R_PARENTHESIS { pin = 1 }

// ANNOTATIONS

annotation_call ::= AT identifier_call (L_BRACKET argument_list R_BRACKET)? {
    pin = 1
    methods = [
        getAnnotationName
        getAnnotationArguments
    ]
}

// BLOCK
block_declaration ::= brace_block | inlined_block


brace_block ::= L_BRACE block_statement* R_BRACE { pin = 1}

inlined_block ::= EQUALS expression { pin = 1 }


// EXPRESSION
expression ::= assignment_expression {
    methods = [
        getExpression
    ]
}

assignment_expression ::= binary_additive_expression assign_expression_part*

assign_expression_part ::= assign_expression
                         | add_assign_expression
                         | sub_assign_expression
                         | mul_assign_expression
                         | div_assign_expression
                         | mod_assign_expression
                         | exp_assign_expression

assign_expression ::= EQUALS assignment_expression { pin = 1 }
add_assign_expression ::= ADD_ASSIGN assignment_expression { pin = 1 }
sub_assign_expression ::= SUB_ASSIGN assignment_expression { pin = 1 }
mul_assign_expression ::= MUL_ASSIGN assignment_expression { pin = 1 }
div_assign_expression ::= DIV_ASSIGN assignment_expression { pin = 1 }
mod_assign_expression ::= MOD_ASSIGN assignment_expression { pin = 1 }
exp_assign_expression ::= EXP_ASSIGN assignment_expression { pin = 1 }

binary_additive_expression ::= binary_multiplicative_expression binary_additive_expression_part*

binary_additive_expression_part ::= binary_add_expression
                       | binary_sub_expression

binary_add_expression ::= PLUS binary_additive_expression { pin = 1 }
binary_sub_expression ::= MINUS binary_additive_expression { pin = 1 }

binary_multiplicative_expression ::= exponential_expression binary_multiplicative_expression_part*

binary_multiplicative_expression_part ::= binary_mul_expression
                             | binary_div_expression
                             | binary_mod_expression

binary_mul_expression ::= ASTERISK binary_multiplicative_expression { pin = 1 }
binary_div_expression ::= SLASH binary_multiplicative_expression { pin = 1 }
binary_mod_expression ::= PERCENT binary_multiplicative_expression { pin = 1 }

exponential_expression ::= operable_expression exponential_expression_part*

exponential_expression_part ::= DOUBLE_ASTERISK exponential_expression

operable_expression ::= prefix_expression? (parenthesized_expression | operable) postfix_expression? cast_expression?

parenthesized_expression ::= L_PARENTHESIS expression R_PARENTHESIS { pin = 1 }

prefix_expression ::= DOUBLE_PLUS | DOUBLE_MINUS | PLUS | MINUS

postfix_expression ::= DOUBLE_PLUS | DOUBLE_MINUS

cast_expression ::= 'f' | 'F' | 'd' | 'D' | 'i' | 'I' | 'c' | 'C'

// GENERAL
literals ::= NUMBER_LITERAL | STRING_LITERAL


operable ::= collection | literals | identifier_call


collection ::= L_BRACKET expression_list R_BRACKET { pin = 1 }


primitives ::= (int | boolean | short | byte | char | string | long) (L_BRACKET R_BRACKET)? {
    methods = [
        getPrimitiveReturnType
    ]
}

argument_list ::= argument_list_part (COMMA argument_list_part)*
argument_list_part ::= IDENTIFIER EQUALS expression { pin = 2 }

parameter_list ::= parameter_list_part (COMMA parameter_list_part)*
parameter_list_part ::= IDENTIFIER COLON primitives {
    pin = 2
    methods = [
        getParameterName
    ]
}

expression_list ::= expression (COMMA expression)*